Resume:

git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all



git init: para inicializar el repositorio git y el staged
git add nombre_del_archivo.txt: enviar el archivo al staged
git status: ver el estado, si se requiere agregar al starget o si se requiere commit
git commit -m "Un cometario sobre el cambio o descricion del archivo"

git log nombreArchivo "Ver historia del archivo"
git show _archivo_ (Muestra los cambios que han existido en el archivo)
git diff _tag1_ _tag2_ (Hace la comparativa de cambios entre el archivo en su etapa en el commit del tag1 y del tag2. Considera al más reciente como tag2 y al original como tag1, SI IMPORTA EL ORDEN DE LOS TAGS)

git push: envía a otro repositorio remoto lo que estamos haciendo
git pull: traer repositorio remoto
git checkout: traer cambios realizados
git checkout idSHA : nos permite viajar en el tiempo. Podemos volver a cualquier versión anterior de un archivo específico o incluso del proyecto entero. Esta también es la forma de crear ramas y movernos entre ellas.
git checkout master file.txt : vuelve al archivo a la ultima version

git reset (--soft, mixed, --hard)

git config: para ver las posibles configiguraciones
git config --list: para ver la lista de configiguraciones hechas
git config --list --show-origin: para mostrar las configuraciones y sus rutas
git rm --cached nombre_del_archivo.txt: para eliminar el archivo del staged(ram)
git rm nombre_del_archivo.txt: para eliminar del repositorio


-- clonar en un origen remoto
git remote add origin https://github.com/samuelpv85/Hyperblog.git
git remote =
git remote -v =
git push origin master = enviar al origen la ramaMaster
git pull origin master = trae desde la ramaMaster al repo local


crear llaves ssh
copiarla en el repositorio
agregar ssh al repositorio local

Cambiar conexion pos SSH
git remote -v
git remote set-url origin git@github.com:samuelpv85/blogP.git

- Tags y versiones
git tag -a v0.1 -m "comentario" diCommit
git tag
git show-ref --tags


git config --global user.name "Samuel Patiño"
git config --global user.email "levivo2@hotmail.com"
pass = tesV2525spv

Trabajando con repositorio remoto
git clone url_del_servidor_remoto: Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.
git push: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.
git fetch: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto).
git merge: También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.
git pull: Básicamente, git fetch y git merge al mismo tiempo.

git branch NameBranch: crear una nueva rama.
git checkout NameBranch: moverse entre ramas.
git push: mandar cambios a un servidor remoto.
git fetch: traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local.
git merge: tiene dos usos. Uno es la fusión de ramas, funcionando como un commit en la rama actual, trayendo la rama indicada. Su otro uso es guardar los cambios de un servidor remoto en nuestro directorio.
git pull: fetch y merge al mismo tiempo.





Git es un sistema de control de versiones distribuido, diseñado por Linus Torvalds. Está pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando estas tienen un gran número de archivos de código fuente.

Git está optimizado para guardar cambios de forma incremental.

Permite contar con un historial, regresar a una versión anterior y agregar funcionalidades.

Lleva un registro de los cambios que otras personas realicen en los archivos.

Git fue diseñado para operar en un entorno Linux. Actualmente, es multiplataforma, es decir, es compatible con Linux, MacOS y Windows. En la máquina local se encuentra Git, se utiliza bajo la terminal o línea de comandos y tiene comandos como merge, pull, add, commit y rebase, entre otros.

Para qué proyectos sirve Git
Con Git se obtiene una mayor eficiencia usando archivos de texto plano, ya que con archivos binarios no puede guardar solo los cambios, sino que debe volver a grabar el archivo completo ante cada modificación, por mínima que sea, lo que hace que incremente demasiado el tamaño del repositorio.

“Guardar archivos binarios en el repositorio de Git no es una buena práctica, únicamente deberían guardarse archivos pequeños (como logos) que no sufran casi modificaciones durante la vida del proyecto. Los binarios deben guardarse en un CDN”.

Características de Git
Git almacena la información como un conjunto de archivos.

No existen cambios, corrupción en archivos o cualquier alteración sin que Git lo sepa.

Casi todo en Git es local. Es difícil que se necesiten recursos o información externos, basta con los recursos locales con los que cuenta.

Git cuenta con 3 estados en los que es posible localizar archivos: Staged, Modified y Committed.

¿Qué es un sistema de control de versiones?
El SCV o VCS (por sus siglas en inglés) es un sistema que registra los cambios realizados sobre un archivo o conjunto de archivos a lo largo del tiempo, de modo que puedas llevar el historial del ciclo de vida de un proyecto, comparar cambios a lo largo del tiempo, ver quién los realizó o revertir el proyecto entero a un estado anterior.

Cualquier tipo de archivo que se encuentre en un ordenador puede ponerse bajo control de versiones.
Que es Git y Github

¿Qué es Github?
Github es una plataforma de desarrollo colaborativo para alojar proyectos utilizando el sistema de control de versiones Git. Se emplea principalmente para la creación de código fuente de programas de computadora.

Puede considerarse a Github como la red social de código para los programadores y en muchos casos es visto como un curriculum vitae, pues aquí se guarda el portafolio de proyectos de programación.

Características de Github
GitHub permite alojar proyectos en repositorios de forma gratuita y pública, pero tiene una forma de pago para privados.

Puedes compartir fácilmente tus proyectos.

Permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos.

Ayuda a reducir significativamente los errores humanos, a tener un mejor mantenimiento de distintos entornos y a detectar fallos de una forma más rápida y eficiente.

Es la opción perfecta para poder trabajar en equipo en un mismo proyecto.

Ofrece todas las ventajas del sistema de control de versiones Git, pero también tiene otras herramientas que ayudan a tener un mejor control de los proyectos.


Contribución creada con los aportes de: Franco Coloccini, Angelo Paul Yenque Tume y Orlando Díaz Torrealva.





********************************************************************************************************
Editores de código, archivos binarios y de texto plano
6/43

RECURSOS
MARCADORES
Un editor de código o IDE es una herramienta que nos brinda muchas ayudas para escribir código, algo así como un bloc de notas muy avanzado. Los editores más populares son VSCode, Sublime Text y Atom, pero no es obligatorio usar alguno de estos para programar. Conoce más a fondo sobre qué es un IDE.

Tipos de archivos y sus diferencias:
Archivos de Texto (.txt): Texto plano normal y sin nada especial. Lo vemos igual sin importar dónde lo abramos, ya sea con el bloc de notas o con editores de texto avanzados.
Archivos RTF (.rtf): Podemos guardar texto con diferentes tamaños, estilos y colores. Pero si lo abrimos desde un editor de código, vamos a ver que es mucho más complejo que solo el texto plano. Esto es porque debe guardar todos los estilos del texto y, para esto, usa un código especial un poco difícil de entender y muy diferente a los textos con estilos especiales al que estamos acostumbrados.
Archivos de Word (.docx): Podemos guardar imágenes y texto con diferentes tamaños, estilos o colores. Al abrirlo desde un editor de código podemos ver que es código binario, muy difícil de entender y muy diferente al texto al que estamos acostumbrados. Esto es porque Word está optimizado para entender este código especial y representarlo gráficamente.
Recuerda que debes habilitar la opción de ver la extensión de los archivos, de lo contrario, solo podrás ver su nombre. La forma de hacerlo en Windows es Vista > Mostrar u ocultar > Extensiones de nombre de archivo.

Conceptos importantes de Git
Bug: Error en el código

Repository: Donde se almacena todo el proyecto, el cual puede vivir tanto en local como en remoto. El repositorio guarda un historial de versiones y, más importante, de la relación de cada versión con la anterior para que pueda hacerse el árbol de versiones con las diferentes ramas.

Fork: Si en algún momento queremos contribuir al proyecto de otra persona, o si queremos utilizar el proyecto de otro como el punto de partida del nuestro. Esto se conoce como “fork”.

Clone: Una vez se decide hacer un fork , hasta ese momento sólo existe en GitHub. Para poder trabajar en el proyecto, toca clonar el repositorio elegido al computador personal.

Branch: Es una bifurcación del proyecto que se está realizando para anexar una nueva funcionalidad o corregir un bug.

Master: Rama donde se almacena la última versión estable del proyecto que se está realizando. La rama master es la que está en producción en cada momento (o casi) y debería estar libre de bugs. Así, si esta rama está en producción, sirve como referente para hacer nuevas funcionalidades y/o arreglar bugs de última hora.

Commit: consiste en subir cosas a la versión local del repositorio. De esta manera se puede trabajar en la rama de forma local sin tener que modificar ninguna versión en remoto ni tener que tener la última versión remota, cosa muy útil en grandes desarrollos trabajados por varias personas.

Push: Consiste en enviar todo lo que se ha confirmado con un commit al repositorio remoto. Aquí es donde se une nuestro trabajo con el de los demás.

Checkout: Acción de descargarse una rama del repositorio GIT local (sí, GIT tiene su propio repositorio en local para poder ir haciendo commits) o remoto.

Fetch: Actualiza el repositorio local bajando datos del repositorio remoto al repositorio local sin actualizarlo, es decir, se guarda una copia del repositorio remoto en el local.

Merge: La acción de merge es la continuación natural del fetch. El merge permite unir la copia del repositorio remoto con tu repositorio local, mezclando los diferentes códigos.

Pull: Consiste en la unión del fetch y del merge, esto es, recoge la información del repositorio remoto y luego mezcla el trabajo en local con esta.

Diff: Se utiliza para mostrar los cambios entre dos versiones del mismo archivo.

Aporte creado por: Nestor Rojas

Archivos de la clase
docutxt.txt
docuword.docx
docurtf.rtf
Lecturas recomendadas

Atom

https://atom.io/


Sublime Text - A sophisticated text editor for code, markup and prose

https://www.sublimetext.com/


Visual Studio Code - Code Editing. Redefined

https://code.visualstudio.com/

********************************************************************************************************

Crea un repositorio de Git y haz tu primer commit
8/43

RECURSOS
MARCADORES
Le indicaremos a Git que queremos crear un nuevo repositorio para utilizar su sistema de control de versiones. Solo debemos posicionarnos en la carpeta raíz de nuestro proyecto y ejecutar el comando:

git init
Recuerda que al ejecutar este comando (y de aquí en adelante) vamos a tener una nueva carpeta oculta llamada .git con toda la base de datos con cambios atómicos en nuestro proyecto.

Recuerda que Git está optimizado para trabajar en equipo, por lo tanto, debemos darle un poco de información sobre nosotros. No debemos hacerlo todas las veces que ejecutamos un comando, basta con ejecutar solo una sola vez los siguientes comandos con tu información:

git config --global user.email "tu@email.com"
git config --global user.name "Tu Nombre"
Existen muchas otras configuraciones de Git que puedes encontrar ejecutando el comando git config --list (o solo git config para ver una explicación más detallada).

Si quieres ver los archivos ocultos de una carpeta puedes habilitar la opción de Vista > Mostrar u ocultar > Elementos ocultos (en Windows) o ejecutar el comando ls -a.

Comandos para iniciar tu repositorio con Git
git init: para inicializar el repositorio git y el staged
git add nombre_del_archivo.txt: enviar el archivo al staged
git status: ver el estado, si se requiere agregar al starget o si se requiere commit
git conf: para ver las posibles configuraciones
git conf --list: para ver la lista de configuraciones hechas
git conf --list --show-origin: para mostrar las configuraciones y sus rutas
git rm --cached nombre_del_archivo.txt: para eliminar el archivo del staged(ram)
git rm nombre_del_archivo.txt: para eliminar del repositorio
Si por algún motivo te equivocaste en el nombre o email que configuraste al principio, lo puedes modificar de la siguiente manera:
git config --global --replace-all user.name “Aquí va tu nombre modificado”
O si lo deseas eliminar y añadir uno nuevo
git config --global --unset-all user.name :Elimina el nombre del usuario
git config --global --add user.name “Aquí va tu nombre”

Aporte creado por: Brand Huatarongo

Archivos de la clase

/
DESCARGAR TODO


historia.txt

Lecturas recomendadas

Cambios en GitHub: de master a main

********************************************************************************************************

Analizar cambios en los archivos de tu proyecto con Git 1
9/43

RECURSOS
MARCADORES
El comando git show nos muestra los cambios que han existido sobre un archivo y es muy útil para detectar cuándo se produjeron ciertos cambios, qué se rompió y cómo lo podemos solucionar. Pero podemos ser más detallados.

Si queremos ver la diferencia entre una versión y otra, no necesariamente todos los cambios desde la creación del archivo, podemos usar el comando git diff commitA commitB.

Recuerda que puedes obtener el ID de tus commits con el comando git log.

Comandos para analizar cambios en GIT
git init: inicializar el repositorio
git add nombre_de_archivo.extensión: agregar el archivo al repositorio
git commit -m “Mensaje”: Agregamos los cambios para el repositorio
git add: Agregar los cambios de la carpeta en la que nos encontramos agregar todo
git status: visualizar cambios
git log nombre_de_archivos.extensión: histórico de cambios con detalles
git push: envía a otro repositorio remoto lo que estamos haciendo
git pull: traer repositorio remoto
ls: listado de carpetas en donde me encuentro. Es decir, como emplear dir en windows.
pwd: ubicación actual
mkdir: make directory nueva carpeta
touch archivo.extensión: crear archivo vacío
cat archivo.extensión: muestra el contenido del archivo
history: historial de comandos utilizados durante esa sesión
rm archivo.extensión: Eliminación de archivo
comando --help: ayuda sobre el comando
git checkout: traer cambios realizados
git rm --cached archivo.extensión: se utiliza para devolver el archivo que se tiene en ram. Cuando escribimos git add, lo devuelve a estado natural mientras está en staging.
git config --list: muestra la lista de configuración de git
git config --list --show-origin: rutas de acceso a la configuración de git
git log archivo.extensión: muestra la historia del archivo


********************************************************************************************************
olver en el tiempo en nuestro repositorio utilizando reset y checkout
12/43

RECURSOS
MARCADORES
El comando git checkout + ID del commit nos permite viajar en el tiempo. Podemos volver a cualquier versión anterior de un archivo específico o incluso del proyecto entero. Esta también es la forma de crear ramas y movernos entre ellas.

También hay una forma de hacerlo un poco más “ruda”: usando el comando git reset. En este caso, no solo “volvemos en el tiempo”, sino que borramos los cambios que hicimos después de este commit.

Hay dos formas de usar git reset: con el argumento --hard, borrando toda la información que tengamos en el área de staging (y perdiendo todo para siempre). O, un poco más seguro, con el argumento --soft, que mantiene allí los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.

Cómo usar Git Reset
Para volver a commits previos, borrando los cambios realizados desde ese commit, podemos utilizar:

git reset --soft [SHA 1]: elimina los cambios hasta el staging area
git reset --mixed [SHA 1]: elimina los cambios hasta el working area
git reset --hard [SHA 1]: regresa hasta el commit del [SHA-1]
Donde el SHA-1 es el identificador del commit
Aporte creado por: Johan Mosquera

********************************************************************************************************
Git reset vs. Git rm
13/43

LECTURA

Git reset y git rm son comandos con utilidades muy diferentes, pero se pueden confundir muy fácilmente.

git rm
Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos “viajar en el tiempo” y recuperar el último commit antes de borrar el archivo en cuestión.

Recuerda que git rm no puede usarse así nomás. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última versión del proyecto:

git rm --cached: Elimina los archivos de nuestro repositorio local y del área de staging, pero los mantiene en nuestro disco duro. Básicamente le dice a Git que deje de trackear el historial de cambios de estos archivos, por lo que pasaran a un estado untracked.
git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).
git reset
Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.

Este comando es muy peligroso y debemos emplearlo solo en caso de emergencia. Recuerda que debemos usar alguna de estas dos opciones:

Hay dos formas de utilizar git reset: con el argumento --hard, borrando toda la información que tengamos en el área de staging (y perdiendo todo para siempre). O, un poco más seguro, con el argumento --soft, que mantiene allí los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.

git reset --soft: Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.
git reset --hard: Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging se borra del historial.
¡Pero todavía falta algo!

git reset HEAD: Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.
La relevancia de estos comandos
Imagina el siguiente caso:

Hacemos cambios en los archivos de un proyecto para una nueva actualización. Todos los archivos con cambios se mueven al área de staging con el comando git add. Pero te das cuenta de que uno de esos archivos no está listo todavía. Actualizaste el archivo, pero ese cambio no debe ir en el próximo commit por ahora.

¿Qué podemos hacer?

Bueno, todos los cambios están en el área de Staging, incluido el archivo con los cambios que no están listos. Esto significa que debemos sacar ese archivo de Staging para poder hacer commit de todos los demás.

¡Al usar git rm lo que haremos será eliminar este archivo completamente de git! Todavía tendremos el historial de cambios de este archivo, con la eliminación del archivo como su última actualización. Recuerda que en este caso no buscábamos eliminar un archivo, solo dejarlo como estaba y actualizarlo después, no en este commit.

En cambio, si usamos git reset HEAD, lo único que haremos será mover estos cambios de Staging a Unstaged. Seguiremos teniendo los últimos cambios del archivo, el repositorio mantendrá el archivo (no con sus últimos cambios, pero sí con los últimos en los que hicimos commit) y no habremos perdido nada.

Conclusión: Lo mejor que puedes hacer para salvar tu puesto y evitar un incendio en tu trabajo es conocer muy bien la diferencia y los riesgos de todos los comandos de Git.

Aporte creado por: Juan David Castro


********************************************************************************************************
Flujo de trabajo básico con un repositorio remoto
14/43

RECURSOS
MARCADORES
Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu computadora. Esto significa que no hay forma de que otros miembros del equipo trabajen en él.

Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.

Estos servidores remotos pueden estar alojados en GitHub, GitLab, BitBucket, entre otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto. Así, el equipo podrá descargarlos, hacer cambios y volverlos a enviar al servidor remoto para que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.

Esto significa que debes aprender algunos nuevos comandos

Comandos para trabajo remoto con GIT
git clone url_del_servidor_remoto: Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.
git push: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.
git fetch: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto).
git merge: También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.
git pull: Básicamente, git fetch y git merge al mismo tiempo.
Adicionalmente, tenemos otros comandos que nos sirven para trabajar en proyectos muy grandes:

git log --oneline:Te muestra el id commit y el título del commit.
git log --decorate: Te muestra donde se encuentra el head point en el log.
git log --stat: Explica el número de líneas que se cambiaron brevemente.
git log -p: Explica el número de líneas que se cambiaron y te muestra que se cambió en el contenido.
git shortlog: Indica que commits ha realizado un usuario, mostrando el usuario y el título de sus commits.
git log --graph --oneline --decorate y
git log --pretty=format:"%cn hizo un commit %h el dia %cd": Muestra mensajes personalizados de los commits.
git log -3: Limitamos el número de commits.
git log --after=“2018-1-2”
git log --after=“today” y
git log --after=“2018-1-2” --before=“today”: Commits para localizar por fechas.
git log --author=“Name Author”: Commits hechos por autor que cumplan exactamente con el nombre.
git log --grep=“INVIE”: Busca los commits que cumplan tal cual está escrito entre las comillas.
git log --grep=“INVIE” –i: Busca los commits que cumplan sin importar mayúsculas o minúsculas.
git log – index.html: Busca los commits en un archivo en específico.
git log -S “Por contenido”: Buscar los commits con el contenido dentro del archivo.
git log > log.txt: guardar los logs en un archivo txt
Aporte creado por: HellenBar


********************************************************************************************************
Introducción a las ramas o branches de Git
15/43

RECURSOS
MARCADORES
Las ramas (branches) son la forma de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la rama principal. Esto porque queremos trabajar una parte muy específica de la aplicación o simplemente experimentar.

La cabecera o HEAD representan la rama y el commit de esa rama donde estamos trabajando. Por defecto, esta cabecera aparecerá en el último commit de nuestra rama principal. Pero podemos cambiarlo al crear una rama (git branch rama, git checkout -b rama) o movernos en el tiempo a cualquier otro commit de cualquier otra rama con los comandos (git reset id-commit, git checkout rama-o-id-commit).

Cómo funcionan las ramas en GIT
Las ramas son la manera de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la rama principal. Esto porque queremos trabajar una parte muy específica de la aplicación o simplemente experimentar.

git branch -nombre de la rama-: Con este comando se genera una nueva rama.

git checkout -nombre de la rama-: Con este comando puedes saltar de una rama a otra.

git checkout -b rama: Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de git brach y git checkout al mismo tiempo.

git reset id-commit: Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag., eliminando el historial de los commit posteriores al tag seleccionado.

git checkout rama-o-id-commit: Nos lleva a cualquier commit sin borrar los commit posteriores al tag seleccionado.

Aporte creado por: Carlos Eduardo Diaz


********************************************************************************************************
Fusión de ramas con Git merge
16/43

RECURSOS
MARCADORES
El comando git merge nos permite crear un nuevo commit con la combinación de dos ramas o branches (la rama donde nos encontramos cuando ejecutamos el comando y la rama que indiquemos después del comando).

Cómo usar Git merge
En este ejemplo, vamos a crear un nuevo commit en la rama master combinando los cambios de una rama llamada cabecera:

git checkout master
git merge cabecera
Otra opción es crear un nuevo commit en la rama cabecera combinando los cambios de cualquier otra rama:

git checkout cabecera
git merge cualquier-otra-rama
Asombroso, ¿verdad? Es como si Git tuviera superpoderes para saber qué cambios queremos conservar de una rama y qué otros de la otra. El problema es que no siempre puede adivinar, sobre todo en algunos casos donde dos ramas tienen actualizaciones diferentes en ciertas líneas en los archivos. Esto lo conocemos como un conflicto.

Recuerda que al ejecutar el comando git checkout para cambiar de rama o commit puedes perder el trabajo que no hayas guardado. Guarda siempre tus cambios antes de hacer git checkout.

Comandos básicos de GitHub
git init: crear un repositorio.
git add: agregar un archivo a staging.
git commit -m “mensaje”: guardar el archivo en git con un mensaje.
git branch: crear una nueva rama.
git checkout: moverse entre ramas.
git push: mandar cambios a un servidor remoto.
git fetch: traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local.
git merge: tiene dos usos. Uno es la fusión de ramas, funcionando como un commit en la rama actual, trayendo la rama indicada. Su otro uso es guardar los cambios de un servidor remoto en nuestro directorio.
git pull: fetch y merge al mismo tiempo.
Comandos para corrección en GitHub
git checkout “codigo de version” “nombre del archivo”: volver a la última versión de la que se ha hecho commit.
git reset: vuelve al pasado sin posibilidad de volver al futuro, se debe usar con especificaciones.
git reset --soft: vuelve a la versión en el repositorio, pero guarda los cambios en staging. Así, podemos aplicar actualizaciones a un nuevo commit.
git reset --hard: todo vuelve a su versión anterior
git reset HEAD: saca los cambios de staging, pero no los borra. Es lo opuesto a git add.
git rm: elimina los archivos, pero no su historial. Si queremos recuperar algo, solo hay que regresar. se utiliza así:
git rm --cached elimina los archivos en staging pero los mantiene en el disco duro.
git rm --force elimina los archivos de git y del disco duro.
Comandos para revisión y comparación en GitHub
git status: estado de archivos en el repositorio.
git log: historia entera del archivo.
git log --stat: cambios específicos en el archivo a partir de un commit.
git show: cambios históricos y específicos hechos en un archivo.
git diff “codigo de version 1” “codigo de version 2”: comparar cambios entre versiones.
git diff: comparar directorio con staging.
Aporte creado por: Pedro Alejandro Silva.



********************************************************************************************************
Resolución de conflictos al hacer un merge
17/43

RECURSOS
MARCADORES
Git nunca borra nada, a menos que nosotros se lo indiquemos. Cuando usamos los comandos git merge o git checkout estamos cambiando de rama o creando un nuevo commit, no borrando ramas ni commits (recuerda que puedes borrar commits con git reset y ramas con git branch -d).

Git es muy inteligente y puede resolver algunos conflictos automáticamente: cambios, nuevas líneas, entre otros. Pero algunas veces no sabe cómo resolver estas diferencias, por ejemplo, cuando dos ramas diferentes hacen cambios distintos a una misma línea.

Esto lo conocemos como conflicto y lo podemos resolver manualmente. Solo debemos hacer el merge, ir a nuestro editor de código y elegir si queremos quedarnos con alguna de estas dos versiones o algo diferente. Algunos editores de código como Visual Studio Code nos ayudan a resolver estos conflictos sin necesidad de borrar o escribir líneas de texto, basta con hacer clic en un botón y guardar el archivo.

Recuerda que siempre debemos crear un nuevo commit para aplicar los cambios del merge. Si Git puede resolver el conflicto, hará commit automáticamente. Pero, en caso de no pueda resolverlo, debemos solucionarlo y hacer el commit.

Los archivos con conflictos por el comando git merge entran en un nuevo estado que conocemos como Unmerged. Funcionan muy parecido a los archivos en estado Unstaged, algo así como un estado intermedio entre Untracked y Unstaged. Solo debemos ejecutar git add para pasarlos al área de staging y git commit para aplicar los cambios en el repositorio.

Cómo revertir un merge
Si nos hemos equivocado y queremos cancelar el merge, debemos usar el siguiente comando:

git merge --abort
Conflictos en repositorios remotos
Al trabajar con otras personas, es necesario utilizar un repositorio remoto.
­
-Para copiar el repositorio remoto al directorio de trabajo local, se utiliza el comando git clone <url>, y para enviar cambios al repositorio remoto se utiliza git push.
-Para actualizar el repositorio local se hace uso del comando git fetch, luego se debe fusionar los datos traídos con los locales usando git merge.

Para traer los datos y fusionarlos a la vez, en un solo comando, se usa git pull.
­- Para crear commits rápidamente, fusionando git add y git commit -m "", usamos git commit -am "".
­- Para generar nuevas ramas, hay que posicionarse sobre la rama que se desea copiar y utilizar el comando git branch <nombre>.
Para saltar entre ramas, se usa el comando git checkout <branch>
­- Una vez realizado los cambios en la rama, estas deben fusionarse con git merge.
El merge ocurre en la rama en la que se está posicionado. Por lo tanto, la rama a fusionar se transforma en la principal.
Los merges también son commits.
Los merges pueden generar conflictos, esto aborta la acción y pide que soluciones el problema manualmente, aceptando o rechazando los cambios que vienen.
Aporte creado por: José Tuzinkievicz, Lottie



********************************************************************************************************
Cambios en GitHub: de master a main
18/43

LECTURA

El escritor Argentino Julio Cortázar afirma que las palabras tienen color y peso. Por otro lado, los sinónimos existen por definición, pero no expresan lo mismo. Feo no es lo mismo que desagradable, ni aromático es lo mismo que oloroso.

Por lo anterior podemos afirmar que los sinónimos no expresan lo mismo, no tienen el mismo “color” ni el mismo “peso”.

Sí, esta lectura es parte del curso profesional de Git & GitHub. Quédate conmigo.

Desde el 1 de octubre de 2020 GitHub cambió el nombre de la rama principal: ya no es “master” -como aprenderás en el curso- sino main.

Este derivado de una profunda reflexión ocasionada por el movimiento #BlackLivesMatter.

La industria de la tecnología lleva muchos años usando términos como master, slave, blacklist o whitelist y esperamos pronto puedan ir desapareciendo.

Y sí, las palabras importan.

Por lo que de aquí en adelante cada vez que escuches a Freddy mencionar “master” debes saber que hace referencia a “main”

Puedes leer un poco más aquí: Cambios en GitHub: de master a main


********************************************************************************************************

Uso de GitHub
19/43

RECURSOS
MARCADORES
GitHub es una plataforma que nos permite guardar repositorios de Git que podemos usar como servidores remotos y ejecutar algunos comandos de forma visual e interactiva (sin necesidad de la consola de comandos).

Luego de crear nuestra cuenta, podemos crear o importar repositorios, crear organizaciones y proyectos de trabajo, descubrir repositorios de otras personas, contribuir a esos proyectos, dar estrellas y muchas otras cosas.

El README.md es el archivo que veremos por defecto al entrar a un repositorio. Es una muy buena práctica configurarlo para describir el proyecto, los requerimientos y las instrucciones que debemos seguir para contribuir correctamente.

Para clonar un repositorio desde GitHub (o cualquier otro servidor remoto) debemos copiar la URL (por ahora, usando HTTPS) y ejecutar el comando git clone + la URL que acabamos de copiar. Esto descargará la versión de nuestro proyecto que se encuentra en GitHub.

Sin embargo, esto solo funciona para las personas que quieren empezar a contribuir en el proyecto.

Cómo conectar un repositorio de GitHub a nuestro documento local
Si queremos conectar el repositorio de GitHub con nuestro repositorio local, que creamos usando el comando git init, debemos ejecutar las siguientes instrucciones:

Guardar la URL del repositorio de GitHub con el nombre de origin
git remote add origin URL
Verificar que la URL se haya guardado correctamente:
git remote
git remote -v
Traer la versión del repositorio remoto y hacer merge para crear un commit con los archivos de ambas partes. Podemos usar git fetch y git merge o solo git pull con el flag --allow-unrelated-histories:
git pull origin master --allow-unrelated-histories
Por último, ahora sí podemos hacer git push para guardar los cambios de nuestro repositorio local en GitHub:
git push origin master
Cómo autenticarte en GitHub 2022
Antes de empezar debemos renombrar la rama ‘máster’ a ‘main’, este es el nuevo estándar en GitHub, para esto:

Primero nos posicionamos en la rama a la que queremos cambiarle el nombre.
Ejecutamos el siguiente comando: git branch -M main
Pasos para crear un token de acceso personal.

Desde el 2022 GitHub ya no deja hacer el push con la contraseña del propio GitHub, para esto tenemos que crear un token, y este token es la contraseña que vamos a colocar cuando nos pida clave

Seguir la secuencia: Ingresamos a nuestra cuenta de GitHub.

Buscamos Settings
Click en Developer settings
Click en Personal access tokens
Click en Generate new token aquí se puede colocar un nombre, la fecha de expiración.
Tildar en repo y luego click en el botón verde Generate token
Aporte creado por: Ana Rotela

Archivos de la clase



# Primero: Guardar la URL del repositorio de GitHub
# con el nombre de origin
git remote add origin URL

# Segundo: Renombrar la rama master
git branch -M master main

# Tercero: Traer la versión del repositorio remoto e
# hice el merge para crear un commit con los archivos
# de ambas partes.
git pull origin main --allow-unrelated-histories

# Cuarto: hacer el git push para guardar
# los cambios de nuestro repositorio local en GitHub:
git push origin main

********************************************************************************************************

Cómo funcionan las llaves públicas y privadas
20/43

RECURSOS
MARCADORES
Las llaves públicas y privadas, conocidas también como cifrado asimétrico de un solo camino, sirven para mandar mensajes privados entre varios nodos con la lógica de que firmas tu mensaje con una llave pública vinculada con una llave privada que puede leer el mensaje.

Las llaves públicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.

Cómo funciona un mensaje cifrado con llaves públicas y privadas
Ambas personas deben crear su llave pública y privada.
Ambas personas pueden compartir su llave pública a las otras partes (recuerda que esta llave es pública, no hay problema si la “interceptan”).
La persona que quiere compartir un mensaje puede usar la llave pública de la otra persona para cifrar los archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos compartir el mensaje.
El mensaje está cifrado y puede ser enviado a la otra persona sin problemas en caso de que los archivos sean interceptados.
La persona a la que enviamos el mensaje cifrado puede emplear su llave privada para descifrar el mensaje y ver los archivos.
Nota: puedes compartir tu llave pública, pero nunca tu llave privada.

Aporte creado por: David Behar

Archivos de la clase

********************************************************************************************************

Configura tus llaves SSH en local
21/43

RECURSOS
MARCADORES
En este ejemplo, aprenderemos cómo configurar nuestras llaves SSH en local.

Cómo generar tus llaves SSH
1. Generar tus llaves SSH**
Recuerda que es muy buena idea proteger tu llave privada con una contraseña.

ssh-keygen -t rsa -b 4096 -C "tu@email.com"
2. Terminar de configurar nuestro sistema.
En Windows y Linux:

Encender el “servidor” de llaves SSH de tu computadora:
eval $(ssh-agent -s)
Añadir tu llave SSH a este “servidor”:
ssh-add ruta-donde-guardaste-tu-llave-privada
En Mac:

Encender el “servidor” de llaves SSH de tu computadora:
eval "$(ssh-agent -s)"
Si usas una versión de OSX superior a Mac Sierra (v10.12), debes crear o modificar un archivo “config” en la carpeta de tu usuario con el siguiente contenido (ten cuidado con las mayúsculas):
Host *

AddKeysToAgent yes
UseKeychain yes
IdentityFile ruta-donde-guardaste-tu-llave-privada
Añadir tu llave SSH al “servidor” de llaves SSH de tu computadora (en caso de error puedes ejecutar este mismo comando pero sin el argumento -K):
ssh-add -K ruta-donde-guardaste-tu-llave-privada
Aporte creado por: Juan Luis Rojas

Archivos de la clase



Generar una nueva llave SSH: (Cualquier sistema operativo)

ssh-keygen -t rsa -b 4096 -C "youremail@example.com"

Comprobar proceso y agregarlo (Windows)

eval $(ssh-agent - s)
ssh-add ~/.ssh/id_rsa
Comprobar proceso y agregarlo (Mac)

eval "$(ssh-agent -s)"
¿Usas macOS Sierra 10.12.2 o superior?
Haz lo siguiente:

cd ~/.ssh
Crea un archivo config…
Con Vim vim config
Con VSCode code config
Pega la siguiente configuración en el archivo…
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile ~/.ssh/id_rsa
Agrega tu llave

ssh-add -K ~/.ssh/id_rsa

********************************************************************************************************
Conexión a GitHub con SSH
22/43

RECURSOS
MARCADORES
La creación de las SSH es necesario solo una vez por cada computadora. Aquí conocerás cómo conectar a GitHub usando SSH.

Luego de crear nuestras llaves SSH podemos entregarle la llave pública a GitHub para comunicarnos de forma segura y sin necesidad de escribir nuestro usuario y contraseña todo el tiempo.

Para esto debes entrar a la Configuración de Llaves SSH en GitHub, crear una nueva llave con el nombre que le quieras dar y el contenido de la llave pública de tu computadora.

Ahora podemos actualizar la URL que guardamos en nuestro repositorio remoto, solo que, en vez de guardar la URL con HTTPS, vamos a usar la URL con SSH:

ssh
git remote set-url origin url-ssh-del-repositorio-en-github
Comandos para copiar la llave SSH:
-Mac:

pbcopy < ~/.ssh/id_rsa.pub
Windows (Git Bash):
clip < ~/.ssh/id_rsa.pub
Linux (Ubuntu):
cat ~/.ssh/id_rsa.pub


********************************************************************************************************
Tags y versiones en Git y GitHub
23/43

RECURSOS
MARCADORES
Los tags o etiquetas nos permiten asignar versiones a los commits con cambios más importantes o significativos de nuestro proyecto.

Comandos para trabajar con etiquetas:
Crear un nuevo tag y asignarlo a un commit: git tag -a nombre-del-tag id-del-commit.
Borrar un tag en el repositorio local: git tag -d nombre-del-tag.
Listar los tags de nuestro repositorio local: git tag o git show-ref --tags.
Publicar un tag en el repositorio remoto: git push origin --tags.
Borrar un tag del repositorio remoto: git tag -d nombre-del-tag y git push origin :refs/tags/nombre-del-tag.
Para generar un comando complejo con varios comandos de una forma optimizada, utilizamos conjuntos de sentencias conocidas como alias.

Cómo aregar un alias solo para git
Para un proyecto:
git config alias.arbolito "log --all --graph --decorate --oneline"
Global:
git config --global alias.arbolito "log --all --graph --decorate --oneline"
Para correrlo:
git arbolito
Aporte creado por: Jorge Sarabia



++++++++

507
Ejecutan este comando en la terminal y queda guardado en los alias pero de git. con esto se puede ejecutar cada que se escribe git superlog

git config --global alias.superlog "log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"

++++++++++

Los apuntes lo realizo con Canva (https://www.canva.com) , también con la aplicación de Android (o iOS). Me sirve bastante para interiorizar los conceptos claves, trato de usar un modelo como Notas de Cornell, no trato de enfocarme mucho en el diseño, pero si algo que me sirva para repasar.

Si tienes un email asociado a una entidad educativa (.edu o similar), pueden adquirir una licencia con mayores funcionalidades que la versión gratuita (https://www.canva.com/education/)

Si quieren aprender a usar la app, tiene cursos que pueden encontrar en este link: https://designschool.canva.com, aunque la herramienta es muy intuitiva.

++++++++++

Para un proyecto:
git config alias.arbolito "log --all --graph --decorate --oneline"

Global:
git config --global alias.arbolito "git log --all --graph --decorate --oneline"

Para correrlo:
git arbolito

++++++++++
Comandos aprendidos en la clase:

alias: se usa para resumir los comandos que nos de flojera escribir, se usa así: alias nombre_de_alias=“git log --all --graph --decorate --oneline”

git tag: se usa para crear tags, versiones o referencias en tu proyecto, se suele usar de esta forma: git tag -a v0.1 -m “versión 0.1 del archivo” 4b0d564
también podemos usar -b para borrar algún tag, escribiendo git tag -b nombre_del_tag.
ese último es lo que aparece cuando hacemos un commit.

git tag: con este sabemos que tags tenemos

git show-ref --tags: nos muestra el tag que está asignado al commit en el que tenemos el tag

git push origin --tags: nos enía los tags que tenemos en el local al repositorio remoto

git push origin :refs/tags/nombre_del_tag: nada que decir, borramos los tags del repositorio remoto jaja
++++++++++

Para ver el funcionamiento de las ramas / branches:

$ git log --all --graph 
//también 
$ git log --all --graph --decorate--oneline
// truco de Linux:
//					 I──Comando
//					V
$ alias _________="_________"
//     ^──Nombre que quieras para el comando	
Para crear un tag:

Copiar el hash del commit que queramos:
$ git tag -a ___________ -m "___________" _________
//		    ^──Nombre del tag			^──Hash
Para enviar nuestros tags al repositorio de GitHub:

1. $ git pull origin master
2. $ git push origin --tags
Para eliminar tags del repositorio local:

$ git tag -d _________
//			^──Nombre del tag que se quiere borrar
Para eliminar tags del repositorio remoto:

Hacer paso anterior
$ git push origin :remote/tags/________________
//						^──Nombre del tag que se quiere eliminar


********************************************************************************************************

Manejo de ramas en GitHub v24/43

git show-branch
git show-branch --all


Si no te funciona el comando gitk es posible no lo tengas instalado por defecto.
Para instalar gitk debemos ejecutar los siguientes comandos:
sudo apt-get update
sudo apt-get install gitk

Repasa: ¿Qué es Git?

Las ramas nos permiten hacer cambios a nuestros archivos sin modificar la versión principal (master). Puedes trabajar con ramas que nunca envías a GitHub, así como pueden haber ramas importantes en GitHub que nunca usas en el repositorio local. Lo crucial es que aprendas a manejarlas para trabajar profesionalmente.

Si, estando en otra rama, modificamos los archivos y hacemos commit, tanto el historial(git log) como los archivos serán afectados. La ventaja que tiene usar ramas es que las modificaciones solo afectarán a esa rama en particular. Si luego de “guardar” los archivos(usando commit) nos movemos a otra rama (git checkout otraRama) veremos como las modificaciones de la rama pasada no aparecen en la otraRama.

Comandos para manejo de ramas en GitHub
Crear una rama:
git branch branchName
Movernos a otra rama:
git checkout branchName
Crear una rama en el repositorio local:
git branch nombre-de-la-rama o git checkout -b nombre-de-la-rama.
Publicar una rama local al repositorio remoto:
git push origin nombre-de-la-rama.
Recuerda que podemos ver gráficamente nuestro entorno y flujo de trabajo local con Git utilizando el comando gitk. Gitk fue el primer visor gráfico que se desarrolló para ver de manera gráfica el historial de un repositorio de Git.

Repasa: Qué es branch.

Aporte creado por: Brayan Mamani

Clases relacionadas
++++++++++

A mi me gusta usar GitKraken como interfaz gráfica. Es fácil de usar y muy interactiva. Pero a la hora del manejo de mis ramas y trabajo con repositorios remotos sigo usando la consola. Me parece mas rápido el uso de la consola y me siento más cómodo con ella, GitKraken lo uso para hacer mis commits y para revisar las diferencias de mi código de forma más amigable. Pero no deja de ser una herramienta muy poderosa para facilitar el trabajo a los desarrolladores. Deberían probarla.
gitkraken.PNG

Responder
Joshval97
Joshval97

Hace 4 años

14
También tiene otras herramientas. No sustituye el uso de la consola pero deberían darle una oportunidad.
https://www.gitkraken.com/


++++++++++

¿Alguien conoce infografías, documentación, resúmenes o algo así sobre Git para tener toda esta información para consultarla de forma rápida como apuntes? ¡Sería de gran ayuda!

Responder
Leonardo Gomez
Leonardo Gomez

Hace 3 años

3
https://git-scm.com/docs

Andrés Felipe Ruiz Buriticá
Andrés Felipe Ruiz Buriticá

Hace 3 años

2
En la pag de educación de github https://github.com/arslanbilal/git-cheat-sheet/blob/master/other-sheets/git-cheat-sheet-es.md o la de atlassian (los de bitbucket) https://es.atlassian.com/git/tutorials/atlassian-git-cheatsheet

++++++++++

Manejo de ramas en GitHub

Primero puede cambiar de rama
git checkout nombre-de-larama

Revisar las ramas que existen
git branch

Cuales don las ramas que existen y cual es su historia
git show-branch

git show-branch --all

Ver todo la historia de manera visual
gitk

********************************************************************************************************

Configurar múltiples colaboradores en un repositorio de GitHub 25/43

https://github.com/guajardo/Comandos-git
https://github.com/arslanbilal/git-cheat-sheet/blob/master/other-sheets/git-cheat-sheet-es.md



Por defecto, cualquier persona puede clonar o descargar tu proyecto desde GitHub, pero no pueden crear commits, ni ramas. Esto quiere decir que pueden copiar tu proyecto pero no colaborar con él. Existen varias formas de solucionar esto para poder aceptar contribuciones. Una de ellas es añadir a cada persona de nuestro equipo como colaborador de nuestro repositorio.

Cómo agregar colaboradores en Github
Solo debemos entrar a la configuración de colaboradores de nuestro proyecto. Se encuentra en:
Repositorio > Settings > Collaborators
Ahí, debemos añadir el email o username de los nuevos colaboradores.

collaborator.png
Si, como colaborador, agregaste erróneamente el mensaje del commit, lo puedes cambiar de la siguiente manera:

Hacer un commit con el nuevo mensaje que queremos, esto nos abre el editor de texto de la terminal:
git commit —amend
Corregimos el mensaje
Traer el repositorio remoto
git pull origin master
Ejecutar el cambio
git push --set-upstream origin master


++++++++++



++++++++++
********************************************************************************************************

Flujo de trabajo profesional: Haciendo merge de ramas de desarrollo a master
26/43

RECURSOS
MARCADORES
Para poder desarrollar software de manera óptima y ordenada, necesitamos tener un flujo de trabajo profesional, que nos permita trabajar en conjunto sin interrumpir el trabajo de otros desarrolladores. Una buena práctica de flujo de trabajo sería la siguiente:

Crear ramas
Asignar una rama a cada programador
El programador baja el repositorio con git pull origin master
El programador cambia de rama
El programador trabaja en esa rama y hace commits
El programador sube su trabajo con git push origin #nombre_rama
El encargado de organizar el proyecto baja, revisa y unifica todos los cambios
Aporte creado por: Alejandro Dubon.

++++++++++


021 

0983925549

++++++++++



++++++++++

********************************************************************************************************
Flujo de trabajo profesional con Pull requests
27/43

https://nvie.com/posts/a-successful-git-branching-model/
https://stackoverflow.com/questions/21657430/why-is-a-git-pull-request-not-called-a-push-request
https://www.dataschool.io/how-to-contribute-on-github/
https://github.com/samuelpv85/blogP/blob/master/git-cheat-sheet-education.pdf

RECURSOS
MARCADORES
En un entorno profesional normalmente se bloquea la rama master, y para enviar código a dicha rama pasa por un code review y luego de su aprobación se unen códigos con los llamados merge request.

Para realizar pruebas enviamos el código a servidores que normalmente los llamamos staging develop (servidores de pruebas) luego de que se realizan las pruebas pertinentes tanto de código como de la aplicación estos pasan al servidor de producción con el ya antes mencionado merge request.

Los PR (pull requests) son la base de la colaboración a proyectos Open Source, si tienen pensando colaborar en alguno es muy importante entender esto y ver cómo se hace en las próximas clases. Por lo general es forkear el proyecto, implementar el cambio en una nueva rama, hacer el PR y esperar que los administradores del proyecto hagan el merge o pidan algún cambio en el código o commits que hiciste.

Proceso de un pull request para trabajo en producción:
Un pull request es un estado intermedio antes de enviar el merge.
El pull request permite que otros miembros del equipo revisen el código y así aprobar el merge a la rama.
Permite a las personas que no forman el equipo, trabajar y colaborar con una rama.
La persona que tiene la responsabilidad de aceptar los pull request y hacer los merge tienen un perfil especial y son llamados DevOps
Aporte creado por: Kevin Morales.

++++++++++

Los PR son la base de la colaboración a proyectos Open Source, si tienen pensando colaborar en alguno es muy importante entender esto y ver cómo se hace en las próximas clases. Por lo general es forkear el proyecto, implementar el cambio en una nueva rama, hacer el PR y esperar que los administradores del proyecto hagan el merge o pidan algún cambio en el código o commits que hiciste.

Un pull request es un estado intermedio antes de enviar el merge.
El pull request permite que otros miembros del equipo revisen el código y así aprobar el merge a la rama.
Permite a las personas que no forman el equipo , trabajar y colaborar con una rama.
La persona que tiene la responsabilidad de aceptar los pull request y hacer los merge tienen un perfil especial y son llamados DevOps
++++++++++

git init // Inicio mi carpeta en la que estoy parada como mi nuevo repositorio git
git add biografia.txt // Añado en Stage mi archivo “biografia.txt"
git add . // Añado todos mis archivos con cambios hechos en esa carpeta a Stage
git commit -m “versión 1” // Hago entrada o commit de mis archivos a mi repositorio en mi disco duro
git commit -am “descripción” // Este comando es un add y un commit junto, y funciona simepre y cuando los archivos que este haciendo commit ya hayan sido anteriormente adheridos al repositorio o mejor dicho que no sean nuevos
git status // Estado de mi rama
git show // Muestra todos mis cambios hechos
git log biografia.txt // Ver el historial de mi archivo
git push // Enviar a mi repositorio remoto todos mis archivos
git pull // Traer a mi repositorio local todos mis archivos
git rm --cached biografia.txt // Revierte el add cuando este se encuentra en Stage. Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.
git rm --force // Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).
git config --list // Me muestra las configuraciones del Git
git config --list --show -origin // Me muestra donde estan ubicadas las configuraciones de Git
git config --global user.name “Alejandro” // Setea de forma global el usuario Git
git config --global user.email "mail@gmail.co” // Setea el correo del usuario Git
git diff // Podemos ver los cambios incluso cuando tengamos archivos en Stage y hayamos hecho cambios nuevos cuando estos archivos estan en Stage
git diff [Hash del commit] [Hash del commit] // Cuando sacamos un log de algun archivo podemos tomar sus hash para mirar las diferencias de sus cambios

/** Volviendo al pasado **/
git reset [Hash del commit] --hard // Cuando si o si queremos volver a un commit anterior en el tiempo
git reset [Hash del commit] --soft // Lo mismo que el anterior con la diferencia de que no va a afectar lo que tengamos en stage
git reset HEAD // Este es el comando para sacar archivos del área de Staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.
git restore biografia.txt // Cuando un archivo es modificado pero no se encuentra en Stage o mucho menos en Commit puede devolverse a su estado inicial con este comando.
git log --stat // Miro los cambios en Bytes que se hicieron en cada Commit y los archivos que se modificaron
git checkout [Hash del commit] biografia.txt // Podemos darle al checkout un hash especifico para mirar un commit en especifico

/Jugando con ramas remotas/
git clone [url_del_servidor_remoto] // Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.
git push // Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.
git fetch: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto).
git merge: También usamos el comando git fetch con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.
git pull: Básicamente, git fetch y git merge al mismo tiempo.
git remote add origin [Direccion de repositorio en git] // Conectamos git local con github
git remote // ramas remotas
git remote -v // ramas remotas pero verbal
git push origin master // Estamos enviando a GitHub nuestros archivos de la rama master que hay local
git pull origin master // Estamos trayendo a Git local nuestros archivos de la rama master que hay en GitHub
git pull origin master --allow-unrelated-histories //En caso de que se reuse a hacer merge por la diferencia de historias o commits
gir remote set-url origin [Direccion de repositorio en git HTTPS o SSH] // Cuando ya tenemos creada una rama remota podemos cambiar la direccion o tipo de conexion con esta sentencia

/Graficando ramas en el terminal/
git log --all -graph --decorate --oneline

/Puedes guardar comandos de git con alias/
alias [Como quieres tu llamar tu alias ej: arbolito] = “[Comando de git que quieres guardar en el alias]”

/TAGS/
–Es recomendado que cuando hagas cambios de tags y se vayan a subir a tu rama remota en GitHub, hagas primero un “git pull origin [rama remota]” para mantenerte actualizado BUENA PRACTICA
git tag // Te muestra la lista de todos los TAGS
git tag -a [Nombre del tag ej: v0.1] -m “Soy un comentario de commit” [Y el hash de la rama ej: 1b56158]
git show-ref --tags
git push origin --tags // Vamos a enviar a origin nuestros tags creados localmente
git tag -d [Nombre del tag a eliminar] // Se usa para eliminar de forma local tus tags
–Como acabamos de hacer un cambio de los tags a manera local, tienes que hacer pull de la rama remota y luego push de tus cambios locales de los tags eliminados
git push origin :refs/tags/[Nombre del tag que quieres borrar] // Para borrar de manera remota, previamente ya que has borrado el tag de forma local

git ls-remote --tags repository-name // Mostramos las tags que tenemos en nuestro repositorio remoto.
git push repository-name --delete tagname // Otra forma de borrar los tags de repositorio remoto

–Notas sobre TAGS de Platzi
Crear un nuevo tag y asignarlo a un commit: git tag -a nombre-del-tag id-del-commit.
Borrar un tag en el repositorio local: git tag -d nombre-del-tag.
Listar los tags de nuestro repositorio local: git tag o git show-ref --tags.
Publicar un tag en el repositorio remoto: git push origin --tags.
Borrar un tag del repositorio remoto: git tag -d nombre-del-tag y git push origin :refs/tags/nombre-del-tag.

/Ramas o Branches/
git branch // Muestro mis ramas locales
git show-branch // Muestra las ramas y algo de informacion de sus commits
git show-branch --all // Muestra lo mismo que el comando anterior pero con algunos detalles mas: Con las ramas remotas tambien
gitk // Nos muestra una ayuda visual historicamente de las ramas de git
git branch [Nombre de la rama que quieres crear]// Creando ramas locales, es recomendable que crees tu nueva rama parandote desde la rama de la cual te vas a basar o recomendable puede ser desde la ultima rama mas actualizada

++++++++++

Pull requests: Sirve para que los demás colaboradores del proyecto observen y aprueben los cambios que se han hecho antes de hacer una fusión (merge) en una rama específica.

++++++++++

NADIE que sea colaborador debe hacer push a master, para hacer reflejar los cambios, se debe hacer Pull request y un colaborador o el mismo propietario del proyecto, hará code review y posteriormente autorizará hacer el merge, lo usual y lo más profesional es que haya un perfil denominado DevOps, que será encargado de hacer estas revisiones y hacer la vida del programador más fácil. El pull request es un estado intermedio antes de hacer el merge.
Como buena práctica, se debería tener una rama de staging o development para probar todas las funcionalidades que se estén evaluando, una vez aprobados estos cambios y se está conforme con el producto final, se realiza un merge con la rama master, nuevamente, lo ideal NUNCA es trabajar sobre master, sino sobre las ramas.

++++++++++

/* Entendi esto , talves algunos terminos medio que confundi pero ahi dejos mis apuntes , si pueden corregirme muchas gracias */

En un entorno de desarrollo profesional la rama master se bloquea

Antes de subir nuestro codigo a un servidor de produccion se utiliza un servidor de pruebas

Existe como una copia de la rama master que se llama staging develop(servidores de prueba)

Si tenemos una rama a la que queremos hacer un merge , antes de hacerlo, git hub o la plataforma que estes utilizando otorga una opcion llamada pull request

En pull request , los demas desarrolladores pueden aprobar o desaprobar ese codigo .

Finalmente Pasa a el servidor de produccion con el merge request ya conocido y termina el proceso

++++++++++

a funcionalidad de Github (en Gitlab llamada merge request y en Bitbucket push request), en la que un colaborador pide que revisen sus cambios antes de hacer merge a una rama, normalmente master (ahora conocida como main).

Al hacer un pull request, se genera una conversación que pueden seguir los demás usuarios del repositorio, así como autorizar y rechazar los cambios.

Cómo se realiza un pull request
Se trabaja en una rama paralela los cambios que se desean git checkout -b <rama>.
Se hace un commit a la rama git commit -am '<Comentario>'.
Se suben al remoto los cambios git push origin <rama>.
En GitHub se hace el pull request comparando la rama master con la rama del fix.
Uno, o varios colaboradores revisan que el código sea correcto y dan feedback (en el chat del pull request).
El colaborador hace los cambios que desea en la rama y lo vuelve a subir al remoto (automáticamente jala la historia de los cambios que se hagan en la rama, en remoto).
Se aceptan los cambios en GitHub.
Se hace merge a master desde GitHub.
Importante: Cuando se modifica una rama, también se modifica el pull request.

++++++++++


Datos importantes de esta clase:
-Los PullRequest no generan un Merge, es un preludio a este para revisar los cambios.
-Dentro de los PullRequest se puede hacer un review para analizar los commits y cambios, esto permite entender qué es lo que se espera fusionar.
-Si un PullRequest no es aprobado, se deben realizar los cambios, hacer un pull y luego si un push para que se vuelvan a evaluar.
-Si un PullRequest es aprobado, pasa a la siguiente etapa de hacer merge. Este merge es semejante a un commit.

Espero que les ayude.

++++++++++



++++++++++

********************************************************************************************************
Utilizando Pull Requests en GitHub
28/43

https://aws.amazon.com/es/devops/what-is-devops/


RECURSOS
MARCADORES
Pull request es una funcionalidad de Github (en Gitlab llamada merge request y en Bitbucket push request), en la que un colaborador pide que revisen sus cambios antes de hacer merge a una rama, normalmente master (ahora conocida como main).

Al hacer un pull request, se genera una conversación que pueden seguir los demás usuarios del repositorio, así como autorizar y rechazar los cambios.

Cómo se realiza un pull request
Se trabaja en una rama paralela los cambios que se desean git checkout -b <rama>.
Se hace un commit a la rama git commit -am '<Comentario>'.
Se suben al remoto los cambios git push origin <rama>.
En GitHub se hace el pull request comparando la rama master con la rama del fix.
Uno, o varios colaboradores revisan que el código sea correcto y dan feedback (en el chat del pull request).
El colaborador hace los cambios que desea en la rama y lo vuelve a subir al remoto (automáticamente jala la historia de los cambios que se hagan en la rama, en remoto).
Se aceptan los cambios en GitHub.
Se hace merge a master desde GitHub.
Importante: Cuando se modifica una rama, también se modifica el pull request.

++++++++++




++++++++++



++++++++++
********************************************************************************************************
Creando un Fork, contribuyendo a un repositorio
29/43



RECURSOS
MARCADORES
Los forks o bifurcaciones son una característica única de GitHub en la que se crea una copia exacta del estado actual de un repositorio directamente en GitHub. Este repositorio podrá servir como otro origen y se podrá clonar (como cualquier otro repositorio). En pocas palabras, lo podremos utilizar como un nuevo repositorio git cualquiera

Un fork es como una bifurcación del repositorio completo. Comparte una historia en común con el original, pero de repente se bifurca y pueden aparecer varios cambios, ya que ambos proyectos podrán ser modificados en paralelo y para estar al día un colaborador tendrá que estar actualizando su fork con la información del original.

Al hacer un fork de un poryecto en GitHub, te conviertes en dueñ@ del repositorio fork, puedes trabajar en este con todos los permisos, pero es un repositorio completamente diferente que el original, teniendo solamente alguna historia en común (como crédito al creado o creadora original).

Los forks son importantes porque es la manera en la que funciona el open source, ya que, una persona puede no ser colaborador de un proyecto, pero puede contribuír al mismo, haciendo mejor software que pueda ser utilizado por cualquiera.

Cómo se hace un fork remoto desde consola en GitHub
Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite al colaborador hacer pull request desde su repositorio propio.

Cuando trabajas en un proyecto que existe en diferentes repositorios remotos (normalmente a causa de un fork), es muy probable que desees poder trabajar con ambos repositorios. Para esto, puedes generar un remoto adicional desde consola.

git remote add <nombre_del_remoto> <url_del_remoto> 
git remote upstream https://github.com/freddier/hyperblog
Al crear un remoto adicional, podremos hacer pull desde el nuevo origen. En caso de tener permisos, podremos hacer fetch y push.

git pull <remoto> <rama>
git pull upstream master
Este pull nos traerá los cambios del remoto, por lo que se estará al día en el proyecto. El flujo de trabajo cambia, en adelante se estará trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request.

git pull upstream master
git push origin master

++++++++++

*******************
****Iniciar Git****
*******************

git int

*******************
****Iniciar Git****
*******************

**********************************
*******Configuración de Git*******
**********************************

git config
git config --list
git config --list --show origin
git config --list --show-origin
git config --global
git config --global user.name "SC"
git config --global user.email "jesuscastellanospaez@hotmail.com"

**********************************
*******Configuración de Git*******
**********************************

********************************************
******Agragar a la zona de preparación******
********************************************

git add Archivo.txt

git add .

********************************************
******Agragar a la zona de preparación******
********************************************

****************************
*********Ver estado*********
****************************

git status

****************************
*********Ver estado*********
****************************

***************************************************************************
*****************Quitar de la zona de preparación**************************
***************************************************************************

git rm --cached archivo.txt (Quitar de la zona de preparación).

***************************************************************************
*****************Quitar de la zona de preparación**************************
***************************************************************************

************************************************************
**********************Realizar commint**********************
************************************************************

git commit -m "Este es el pimer commit de este archivo"
git commit -am "Este es el pimer commit de este archivo"

************************************************************
**********************Realizar commint**********************
************************************************************

*****************************************************
*******Ver el historial de cambios del archivo*******
*****************************************************

git log
git log Archivo.txt

*****************************************************
*******Ver el historial de cambios del archivo*******
*****************************************************

***************************************************************
************Muestra todos los cambios sobre un archivo*********
***************************************************************

git show Archivo.txt

***************************************************************
************Muestra todos los cambios sobre un archivo*********
***************************************************************

**************************************
**********Comparar versiones**********
**************************************

git diff commint commint

**************************************
**********Comparar versiones**********
**************************************

*****************************************************************************
************************Volver a una versión anterior************************
*****************************************************************************

git reset commit --hard (borramos todos los cambios y lo que tengamos en staging) 

git reset commit --soft (soft conservamos cambios y lo que tengamos en staging) 

git checkout (commit) Archivo.txt

git checkout (rama) Archivo.txt
*****************************************************************************
************************Volver a una versión anterior************************
*****************************************************************************

****************************************************************************
**************************Ver Cambio en bytes*******************************
****************************************************************************

git log --stat(Cambio en bytes)

****************************************************************************
**************************Ver Cambio en bytes*******************************
****************************************************************************

***************************************************************************
****************************Crear una rama*********************************
***************************************************************************

git branch (branchName)

***************************************************************************
****************************Crear una rama*********************************
***************************************************************************


***************************************************************************
**************************Cambiar de rama**********************************
***************************************************************************

git checkout (branchName)

***************************************************************************
**************************Cambiar de rama**********************************
***************************************************************************

*******************************************************************
************************Merge entre branchs************************
*******************************************************************

git merge (branchName)

**Estar en la rama master o en la que se quiere dejar el <Head>**
*******************************************************************
************************Merge entre branchs************************
*******************************************************************

****************************************************
************Traer un repositorio externo************
****************************************************

git remote add origin (url)
git remote (muestra el origen)
git remote -v(es verval)

git pull origin master --allow-unrelated-histories (Fuerza la union de las diferentes historias)

git pull origin master (Descarga cambios)

git push (origin) (master) (Sube Cambios)
****************************************************
************Traer un repositorio externo************
****************************************************

*************************************
**************Seguridad**************
*************************************

ssh-keygen -t rsa -b 4096 -C "jesuscastellanospaez@gmail.com" (crea la llave publica y privada)
eval $(ssh-agent -s) (saber si el agente ssh esta ejecuntando)
ssh-add ~/.ssh/id_rsa (agregar la llave privada)

git remote set-url origin git@github.com:gsuscastellanosSC/hyperblog.git (cambiar url para que sea con ssh)


*************************************
**************Seguridad**************
*************************************

**********************************
***************TAGS***************
**********************************

git log --all(Muesta toda la historia)
git log --all --graph (Muestra toda la historia con la ineracción de las ramas)
git log --all --graph --decorate --oneline
alias arbolito="git log --all --graph --decorate --oneline"(forma de alias en linux)

git tag -a v0.1 -m "apendiendo tags en git" (hash del commit) (crear un tag)
git show-ref --tags

git push origin --tags (enviar los tags al repositorio remoto)
git tag -d v0.1   && $ git push origin :refs/tags/v0.1 (Borrar tags)


**********************************
***************TAGS***************
**********************************

************************
********ramas***********
************************

git show-branch --all (¿Cuales branch existen y sus historias)
gitk (igual que la anterior per con gui)
git push origin :[nombre_branch] (Elimina rama remota)


************************
********ramas***********
************************

************************
***Crear fuente nueva***
************************

git remote add upstream (url-github)
git pull upstream master (trae todos los cabios de master del origen upstream)

************************
***Crear fuente nueva***
************************


++++++++++

Para hacer una contribución a un proyecto de Github hay que seguir los siguientes pasos:

Darle al botón de Fork en Github
Hacer los cambios y darle push a ellos en mi repositorio
Hacer un pull request con mis cambios en alguna de las ramas del proyecto original y esperar
Una vez aprueben o rechacen mis cambios seré notificado en la cuenta de github
Pero también pasa algo muy interesante y es que cuando yo he hecho un fork, el proyecto original sigue avanzando y el mio se va quedando atras, así que para traer los cambios del proyecto original eso se hace de la siguiente manera:

Crear una nueva fuente para hacer pull desde el repositorio forkeado. Por ejemplo:
git remote add upstream git@github.com:freddier/hyperblog.git
Nota: la palabra upstream es opcional pero es lo que normalmente se usa en la industria.
Verificamos que hay una nueva fuente de datos con
git remote -v
Hacer pull de upstream/master
git pull upstream master
Hacer un commit para fusionar los cambios que hemos traído
git commit -am “Fusion”
Hacer un push para mandar los cambios a nuestro repositorio original
git push origin master

++++++++++

Forks o Bifurcaciones
Es una característica única de GitHub en la que se crea una copia exacta del estado actual de un repositorio directamente en GitHub, éste repositorio podrá servir como otro origen y se podrá clonar (como cualquier otro repositorio), en pocas palabras, lo podremos utilizar como un git cualquiera
.
Un fork es como una bifurcación del repositorio completo, tiene una historia en común, pero de repente se bifurca y pueden variar los cambios, ya que ambos proyectos podrán ser modificados en paralelo y para estar al día un colaborador tendrá que estar actualizando su fork con la información del original.
.
Al hacer un fork de un poryecto en GitHub, te conviertes en dueñ@ del repositorio fork, puedes trabajar en éste con todos los permisos, pero es un repositorio completamente diferente que el original, teniendo alguna historia en común.
.
Los forks son importantes porque es la manera en la que funciona el open source, ya que, una persona puede no ser colaborador de un proyecto, pero puede contribuír al mismo, haciendo mejor software que pueda ser utilizado por cualquiera.
.
Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite al colaborador hacer pull request desde su repositorio propio.

Trabajando con más de 1 repositorio remoto
Cuando trabajas en un proyecto que existe en diferentes repositorios remotos (normalmente a causa de un fork) es muy probable que desees poder trabajar con ambos repositorios, para ésto puedes crear un remoto adicional desde consola.

git remote add <nombre_del_remoto> <url_del_remoto> 
git remote upstream https://github.com/freddier/hyperblog
Al crear un remoto adicional podremos, hacer pull desde el nuevo origen (en caso de tener permisos podremos hacer fetch y push)

git pull <remoto> <rama>
git pull upstream master
Éste pull nos traerá los cambios del remoto, por lo que se estará al día en el proyecto, el flujo de trabajo cambia, en adelante se estará trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request.

git pull upstream master
git push origin master


********************************************************************************************************
Haciendo deployment a un servidor
30/43

RECURSOS
MARCADORES
Deploy es el proceso que permite enviar al servidor uno o varios archivos. Este servidor puede ser de prueba, desarrollo o producción.

En el siguiente ejemplo veremos cómo se realiza el deployment de un documento en un servidor web básico.

Pasos para hacer deployment en un servidor web:
Entrar a la capeta de los archivos del servidor.
Copiar link en clone, elegir entre HTTPS o SSH del repositorio a contribuir.
-En la carpeta deseada se clona el repositorio:
git clone url
Deploy:
Realizar cambios y commit en GitHub.
Traer al Repositorio local las actualizacion para el servidor en la capeta de los archivos del servidor.
git pull ramaRemota main
Nota: Siempre se debe proteger el archivo .git. Dependiendo del software para el servidor web, existen diferentes maneras. La conexión entre GitHub y el servidor se puede realizar mediante: Travis (pago) o Jenkis (Open source).


++++++++++

Para practicar de forma fácil pueden levantar un servidor local con python. Primero nos ubicamos en la carpeta del proyecto que queremos inicializar en el servidor y luego ejecutamos el comando según sea python2 o 3.
con Python 2:
python -m SimpleHTTPServer 8000
con Python 3.x:
python3 -m http.server 8000
El 8000 indica el puerto donde va a iniciar, entonces en el navegador vamos a 127.0.0.1:8000 y saldrá nuestro proyecto.
Se puede clonar el repo tranquilamente desde la terminal y para acceder, agrego en la barra de direcciones la ruta a la que quiero ir como hizo Freddy.

++++++++++

Cordial saludo Devs.

Utilizo una herramienta para administrar ramas y observar el flujo de git.

Permite enlazar con las cuentas de GitHub, GitLab, BitBucket, entre otras.
Permite hacer push, pull
GitKraken

++++++++++

https://francoisromain.medium.com/vps-deploy-with-git-fea605f1303b
https://marklodato.github.io/visual-git-guide/index-es.html

********************************************************************************************************
Ignorar archivos en el repositorio con .gitignore
32/43

RECURSOS
MARCADORES
No todos los archivos que agregas a un proyecto deberían ir a un repositorio. Por ejemplo, cuando tienes un archivo donde están tus contraseñas que comúnmente tienen la extensión .env o cuando te estás conectando a una base de datos; son archivos que nadie debe ver.

Por diversas razones, no todos los archivos que agregas a un proyecto deberían guardarse en un repositorio. Esto es porque hay archivos que no todo el mundo debería de ver, y hay archivos que al estar en el repositorio ralentizan el proceso de desarrollo (por ejemplo: los binary large objects, blob, que tardan en descargarse).

Para que no se suban estos archivos no deseados se puede crear un archivo con el nombre .gitignore en la raíz del repositorio con las reglas para los archivos que no se deberían subir: Aquí puedes ver la sintaxis de los .gitignore.

Las razones principales para tomar la decisión de no agregar un archivo a un repositorio son:

Es un archivo con contraseñas (normalmente con la extensión .env)
Es un blob (binary large object, objeto binario grande), mismos que son difíciles de gestionar en git.
Son archivos que se generan corriendo comandos, por ejemplo la carpeta node_modules, que genera npm al correr el comando npm install
Aporte creado por: David Behar.






++++++++++
Ignorar archivos para no subirlos al repositorio (.gitignore)
Por diversas razones, no todos los archivos que agregas a un proyecto deberían guardarse en un repositorio, ésto porque hay archivos que no todo el mundo debería de ver, y hay archivos que al estar en el repositorio alentan el proceso de desarrollo (por ejemplo los binary large objects, blob, que se tardan en descargarse).
.
Para que no se suban estos archivos no deseados se puede crear un archivo con el nombre .gitignore en la raíz del repositorio con las reglas para los archivos que no se deberían subir (ver [sintaxis de los .gitignore(https://git-scm.com/docs/gitignore)).
.
Las razones principales para tomar la decisión de no agregar un archivo a un repositorio son:
.

Es un archivo con contraseñas (normalmente con la extensión .env)
Es un blob (binary large object, objeto binario grande), mismos que son difíciles de gestionar en git.
Son archivos que se generan corriendo comandos, por ejemplo la carpeta node_modules que genera npm al correr el comando npm install



++++++++++



++++++++++



********************************************************************************************************
Readme.md es una excelente práctica
33/43

RECURSOS
MARCADORES
README.md es el lugar donde se explica de qué trata el proyecto, cómo utilizarlo y demás información que se considere que se deba conocer cualquier persona que vaya a trabajar de alguna forma con el proyecto.
.
Los archivos README son escritos en un lenguaje llamado markdown, por eso la extensión .md, mismo que es un estándar de escritura en diversos sitios (como Platzi, Wikipedia y el mismo GitHub). Aquí puedes ver las reglas de markdown.

Los README.md pueden estar en todas las carpetas, pero el más importante es el que se encuentra en la raíz. Este documento ayuda a que los colaboradores sepan información relevante del proyecto, módulo o sección. Puedes crear cualquier archivo con la extensión .md pero solo los README.md los mostrará por defecto GitHub.



********************************************************************************************************
Tu sitio web público con GitHub Pages
34/43

RECURSOS
MARCADORES
GitHub tiene un servicio de hosting gratis llamado GitHub Pages. Con él, puedes tener un repositorio alojado en GitHub y hacer que el contenido se muestre en la web en tiempo real.

Este es un sitio para nuestros proyectos donde lo único que tenemos que hacer es tener un repositorio alojado. En la página, podemos seguir las instrucciones para crear este repositorio

Pasos para subir un repositorio a GitHub Pages
Debemos tomar la llave SSH y hacer un git clone #SSHexample en mi computador local (Home).
Luego, accederemos a la carpeta nueva que aparece en nuestra máquina local.
Creamos un nuevo archivo que se llame index.html
Guardamos los cambios, hacemos un git pull y seguido de esto un git push a master.
Vamos a las opciones de settings de este repositorio y, en la parte de abajo, en la columna Github Pages, configuramos el source o fuente para que traiga la rama master
Guardamos los cambios.
Después de esto, podremos ver nuestro trabajo en la web como si tuviéramos nuestro propio servidor.

Aporte creado por: Jhon Bangera.

Archivos de la clase

++++++++++

Para los que estén en 2022 haciendo el curso, y no les salga su página sin poner el index.html , en Settings de su repositorio deben especificar que el branch sea main y que la ruta la tome de /docs, así ya no va a tomar el README como el index.

De esta manera, su página se muestra directo con:
https://username.github.io/ sin necesidad de agregar index.html




********************************************************************************************************
Git Rebase: reorganizando el trabajo realizado
35/43

RECURSOS
MARCADORES
Rebase es el proceso de mover o combinar una secuencia de confirmaciones en una nueva confirmación base. La reorganización es muy útil y se visualiza fácilmente en el contexto de un flujo de trabajo de ramas de funciones. El proceso general se puede visualizar de la siguiente manera.

rebase1.png
Para hacer un rebase en la rama feature de la rama master, correrías los siguientes comandos:

git checkout feature
git rebase master
Esto trasplanta la rama feature desde su locación actual hacia la punta de la rama master:

rebase2.png
Ahora, falta fusionar la rama feature con la rama master

git checkout master
git rebase feature
# No reorganices el historial público
Nunca debes reorganizar las confirmaciones una vez que se hayan enviado a un repositorio público. La reorganización sustituiría las confirmaciones antiguas por las nuevas y parecería que esa parte del historial de tu proyecto se hubiera desvanecido de repente.

El comando rebase es **_una mala práctica, sobre todo en repositorios remotos. Se debe evitar su uso, pero para efectos de práctica te lo vamos a mostrar, para que hagas tus propios experimentos. Con rebase puedes recoger todos los cambios confirmados en una rama y ponerlos sobre otra.

# Cambiamos a la rama que queremos traer los cambios
git checkout experiment
# Aplicamos rebase para traer los cambios de la rama que queremos 
git rebase master
Aporte creado por: Carlos Eduardo Diaz

++++++++++


Rebase sirve también para cambiar la historia de nuestros commits en la misma rama, si tienen muchos commits con cambios pequeños estos se pueden unificar para hacer que su log se vea mas limpio.
Les recomiendo buscar git rebase interactive
Capture.PNG
**Evitar hacer rebase en el repositorio remoto a menos que tengan claro que están haciendo.

++++++++++

Un caso de uso que se me ocurre para rebase es cuando creo una branch, trabajo en ella… y por cuestiones de la vida no me doy cuenta que creé la branch con faltas de ortografía jajaja.

Entonces creo otra branch con el nombre correcto, luego los rebase y listo. Nadie se da cuenta en la historia del repositorio que cree una branch con faltas de ortografía jajajaja

Responder
Moises10
Moises10

Hace 3 años

13
Jajajajaaja creo que mejor práctica es reescribiendo la historia de la rama con este comando .
git commit --amend --no-edit .

Con este comando creo yo que una mejor practica para rescribir el mensaje y los archivos .
git commit --amend

Tomás Felipe Beltrán Pulido
Tomás Felipe Beltrán Pulido

Hace un año

2
Se puede usar el siguiente comando en tal caso:

git branch -m <viejo nombre de la rama> <nuevo nombre de la rama>
Básicamente renombras la rama que tienes. No sé por qué se ha coloreado así

++++++++++

Me puse a trastear con el comando rebase y me di cuenta que cuando utilizamos el comando gitk en background, es decir colocándole un & al final (sin espacio), es posible notar como se va dibujando los commits gráficamente a medida que vamos trabajando en el proyecto. Es muy útil para tener siempre presente en donde estamos parado con respecto a los commits y las ramas

++++++++++
Hice el mismo ejemplo en mi maquina y al hacer el rebase me saco errores por conflicto 😅. Pero seguí los pasos que git me indico:

Resolve all conflicts manually, mask them as resolved with: git add/rm <conflicted_files>", then run “git rebase --continue”

Basicamente lo que dice es que hay que:

resolver los conflictos manualmente

una vez resueltos añadirlos con git add (no dar commit porque entra en una especie de limbo)

luego correr el comando git rebase --continue

Responder
Edixon javier Pabon Lizcano
Edixon javier Pabon Lizcano

Hace 3 años

4
Que enredo es si no haces el procedimiento bien, para salir tienes que utilizar:
git rebase --abort
git rebase --skip
git rebase --continue
Por si a alguien le paso lo mismo.



********************************************************************************************************

it Stash: Guardar cambios en memoria y recuperarlos después
36/43

RECURSOS
MARCADORES
El stashed nos sirve para guardar cambios para después, Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de rama o branch sin perder el trabajo que todavía no guardamos en un commit

Ésto es especialmente útil porque hay veces que no se permite cambiar de rama, ésto porque tenemos cambios sin guardar, no siempre es un cambio lo suficientemente bueno como para hacer un commit, pero no queremos perder ese código en el que estuvimos trabajando.

El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, más adelante, retomar el trabajo con los archivos que teníamos en Staging, pero que podemos recuperar, ya que los guardamos en el Stash.

git stash
El comando git stash guarda el trabajo actual del Staging en una lista diseñada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.

Para agregar los cambios al stash se utiliza el comando:

git stash

Podemos poner un mensaje en el stash, para asi diferenciarlos en git stash list por si tenemos varios elementos en el stash. Ésto con:

git stash save "mensaje identificador del elemento del stashed"

Obtener elelmentos del stash
El stashed se comporta como una Stack de datos comportándose de manera tipo LIFO (del inglés Last In, First Out, «último en entrar, primero en salir»), así podemos acceder al método pop.

El método pop recuperará y sacará de la lista el último estado del stashed y lo insertará en el staging area, por lo que es importante saber en qué branch te encuentras para poder recuperarlo, ya que el stash será agnóstico a la rama o estado en el que te encuentres. Siempre recuperará los cambios que hiciste en el lugar que lo llamas.

Para recuperar los últimos cambios desde el stash a tu staging area utiliza el comando:

git stash pop

Para aplicar los cambios de un stash específico y eliminarlo del stash:

git stash pop stash@{<num_stash>}

Para retomar los cambios de una posición específica del Stash puedes utilizar el comando:

git stash apply stash@{<num_stash>}

Donde el <num_stash> lo obtienes desden el git stash list

Listado de elementos en el stash
Para ver la lista de cambios guardados en Stash y así poder recuperarlos o hacer algo con ellos podemos utilizar el comando:

git stash list

Retomar los cambios de una posición específica del Stash || Aplica los cambios de un stash específico

Crear una rama con el stash
Para crear una rama y aplicar el stash más reciente podemos utilizar el comando

git stash branch <nombre_de_la_rama>

Si deseas crear una rama y aplicar un stash específico (obtenido desde git stash list) puedes utilizar el comando:

git stash branch nombre_de_rama stash@{<num_stash>}

Al utilizar estos comandos crearás una rama con el nombre <nombre_de_la_rama>, te pasarás a ella y tendrás el stash especificado en tu staging area.

Eliminar elementos del stash
Para eliminar los cambios más recientes dentro del stash (el elemento 0), podemos utilizar el comando:

git stash drop

Pero si, en cambio, conoces el índice del stash que quieres borrar (mediante git stash list) puedes utilizar el comando:

git stash drop stash@{<num_stash>}

Donde el <num_stash> es el índice del cambio guardado.

Si, en cambio, deseas eliminar todos los elementos del stash, puedes utilizar:

git stash clear

Consideraciones:
El cambio más reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomará los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intención de que git tenga un seguimiento de ese archivo, o también utilizando el comando git stash -u (que guardará en el stash los archivos que no estén en el staging).
Al aplicar un stash este no se elimina, es buena práctica eliminarlo.
Aporte creado por: David Behar.
++++++++++


Stashed:
El stashed nos sirve para guardar cambios para después, Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de rama sin perder el trabajo que todavía no guardamos en un commit

Ésto es especialmente útil porque hay veces que no se permite cambiar de rama, ésto porque porque tenemos cambios sin guardar, no siempre es un cambio lo suficientemente bueno como para hacer un commit, pero no queremos perder ese código en el que estuvimos trabajando.

El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, más adelante, retomar el trabajo con los archivos que teníamos en Staging pero que podemos recuperar ya que los guardamos en el Stash.

git stash
El comando git stash guarda el trabajo actual del Staging en una lista diseñada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.

Para agregar los cambios al stash se utiliza el comando:

git stash
Podemos poner un mensaje en el stash, para asi diferenciarlos en git stash list por si tenemos varios elementos en el stash. Ésto con:

git stash save "mensaje identificador del elemento del stashed"
Obtener elelmentos del stash
El stashed se comporta como una Stack de datos comportándose de manera tipo LIFO (del inglés Last In, First Out, «último en entrar, primero en salir»), así podemos acceder al método pop.

El método pop recuperará y sacará de la lista el último estado del stashed y lo insertará en el staging area, por lo que es importante saber en qué branch te encuentras para poder recuperarlo, ya que el stash será agnóstico a la rama o estado en el que te encuentres, siempre recuperará los cambios que hiciste en el lugar que lo llamas.

Para recuperar los últimos cambios desde el stash a tu staging area utiliza el comando:

git stash pop
Para aplicar los cambios de un stash específico y eliminarlo del stash:

git stash pop stash@{<num_stash>}
Para retomar los cambios de una posición específica del Stash puedes utilizar el comando:

git stash apply stash@{<num_stash>}
Donde el <num_stash> lo obtienes desden el git stash list

Listado de elementos en el stash
Para ver la lista de cambios guardados en Stash y así poder recuperarlos o hacer algo con ellos podemos utilizar el comando:

git stash list
Retomar los cambios de una posición específica del Stash || Aplica los cambios de un stash específico

Crear una rama con el stash
Para crear una rama y aplicar el stash mas reciente podemos utilizar el comando

git stash branch <nombre_de_la_rama>
Si deseas crear una rama y aplicar un stash específico (obtenido desde git stash list) puedes utilizar el comando:

git stash branch nombre_de_rama stash@{<num_stash>}
Al utilizar estos comandos crearás una rama con el nombre <nombre_de_la_rama>, te pasarás a ella y tendrás el stash especificado en tu staging area.

Eliminar elementos del stash
Para eliminar los cambios más recientes dentro del stash (el elemento 0), podemos utilizar el comando:

git stash drop
Pero si en cambio conoces el índice del stash que quieres borrar (mediante git stash list) puedes utilizar el comando:

git stash drop stash@{<num_stash>}
Donde el <num_stash> es el índice del cambio guardado.

Si en cambio deseas eliminar todos los elementos del stash, puedes utilizar:

git stash clear
Consideraciones:

El cambio más reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomará los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intención de que git tenga un seguimiento de ese archivo, o también utilizando el comando git stash -u (que guardará en el stash los archivos que no estén en el staging).
Al aplicar un stash este no se elimina, es buena práctica eliminarlo.

++++++++++

git stash : Guarda el trabajo actual de manera temporal. (Archivos modificados o eliminados)
git stash -u : Crea un stash con todos los archivos. (Añadiendo los creados Untracked)
git stash save “mensaje” : Crea un stash con el mensaje especificado.
git stash list : Permite visualizar todos los stash existentes.
git stash clear : Elimina todos los stash existentes.
git stash drop : Elimina el stash más reciente. El que tiene num_stash=0.
git stash drop stash@{num_stash} : Elimina un stash específico.
git stash apply : Aplica el stash más reciente. El que tiene num_stash=0.
git stash apply stash@{num_stash} : Aplica los cambios de un stash específico.
git stash pop : Aplica el stash más reciente y lo elimina. El que tiene num_stash=0.
git stash pop stash@{num_stash} : Aplica los cambios de un stash específico y elimina lo stash.
git stash branch nombre_de_rama : Crea una rama y aplica el stash mas reciente.
git stash branch nombre_de_rama stash@{num_stash} : Crea una rama y aplica el stash especificado.

Consideraciones:

El cambio más reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomará los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intención de que git tenga un seguimiento de ese archivo, o también utilizando el comando git stash -u.
Al aplicar un stash este no se elimina, es buena práctica eliminarlo.

++++++++++


Comandos vistos en esta clase:

- git stash = guarda temporalmente el último commit de la rama actual.

- git stash list = muestra el último stash realizado.

- git stash pop = carga el último stash realizado en la rama actual.

- git stash branch nombre_rama = guarda el último stash en una nueva rama. Después se debe hacer commit desde la nueva rama creada.

- git stash = se puede usar también para recuperar el último commit de la rama actual, en caso de haber cometido errores. Es como una especie de ctrl+z de git.

- git stash drop = borra el último stash realizado.

********************************************************************************************************

Git Clean: limpiar tu proyecto de archivos no deseados
37/43

RECURSOS
MARCADORES
Mientras estamos trabajando en un repositorio podemos añadir archivos a él, que realmente no forma parte de nuestro directorio de trabajo, archivos que no se deberían de agregar al repositorio remoto.

El comando clean actúa en archivos sin seguimiento, este tipo de archivos son aquellos que se encuentran en el directorio de trabajo, pero que aún no se han añadido al índice de seguimiento de repositorio con el comando add.

$ git clean

La ejecución del comando predeterminado puede producir un error. La configuración global de Git obliga a usar la opción force con el comando para que sea efectivo. Se trata de un importante mecanismo de seguridad ya que este comando no se puede deshacer.

Revisar que archivos no tienen seguimiento.
$ git clean --dry-run

Eliminar los archivos listados de no seguimiento.
$ git clean -f
Git clean tiene muchísimas opciones adicionales, que puedes explorar al ver su documentación oficial.

Aporte creado por: Alex Camacho.
++++++++++

El parametro -d ayuda con el borrado de carpetas untracked. Por ejemplo: git clean -df hubiera borrado la carpeta “css - copia”


++++++++++

cabo de descubrir estos comando nuevos. Aquí se los dejo por si los quieren probar.
Para hacer simulaciones:

$ git clean -fn  //Archivos
$ git clean -dn  //Directorios
$ git clean -xn  //Archivos ignorados
Para eliminar de verdad:

$ git clean -f   //Archivos
$ git clean -df  //Directorios
$ git clean -xf  //Archivos ignorados
También se pueden combinar:

$ git clean -xdf  //Eliminar los tres tipos de archivos juntos

++++++++++

Comandos utiles de git clean:

git clean --dry-run # Con este comando es como una simulación, donde te avisa que archivo va a eliminar si aplicas un clean completo.

git clean -n #Versión abreviada de git --dry-run

git clean -f #Eliminar todos los archivos untracked listados ahora si (que no sean carpetas o archivos ignorados)

git clean -f -d # Eliminar los archivos untracked listados, agregando el -d le decimos que también las carpetas que se vuelvan vacias como resultado de eliminar los archivos con el argumento de -f

git clean -x # Borra las copias incluyendo las que están dentro de un .gitignore

git clean -X # Borra solamente los archivos ignorados por git

git clean -q # Muestra los errores que tuvo la ejecución, pero no los archivos que fueron borrados

git clean -i #Modo interactivo de git clean

+++++++


Git Clean

Sintaxis
git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>
Parámetros

-  -d	Elimine directorios sin seguimiento además de archivos sin seguimiento. Si un directorio sin seguimiento es administrado por un repositorio de Git diferente, no se elimina de forma predeterminada. Use la opción -f dos veces si realmente desea eliminar dicho directorio.

-f, --fuerza	Si la variable de configuración de Git limpia. requireForceno está configurado como falso, git clean se negará a eliminar archivos o directorios a menos que se le proporcione -f, -n o -i. Git se negará a eliminar directorios con subdirectorio o archivo .git a menos que se proporcione una segunda -f.
-i, --interactivo	Solicita de forma interactiva la eliminación de cada archivo.
-n, --ejecución en seco	Solo muestra una lista de archivos que se eliminarán, sin eliminarlos realmente.
-q,--tranquilo	Solo muestra errores, no la lista de archivos eliminados con éxito.


********************************************************************************************************


++++++++++




++++++++++



++++++++++


********************************************************************************************************


++++++++++




++++++++++



++++++++++


********************************************************************************************************


++++++++++




++++++++++



++++++++++